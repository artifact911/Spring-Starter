Сервисы взаимодействуют друг с другом и соответсвенно нужно управлять транзакциями и отслеживать их.
    Кто открыл, тот и закрывает. И Если уже открыта, то открывать новую не нужно. Обычно над каждыйм сервисом
    есть @Transactional и все работает автоматически. Но тем не менее, мы можем настраивать. И из всех нас больше всего
    интересует
        1. Propagation propagation() default Propagation.REQUIRED - именно это влияет на то, как осуществляется взаимодействие
            между различными cglib-proxy и открывать либо не открывать транзакцию. По умолчанию это REQUIRED.
            Какие есть еще:
                - REQUIRED - означает, что выполнять код нужно в текущей транзакции если она есть. Если ее нет - тогда
                    открыть новую;
                - SUPPORTS - смотрит, сущесвует ли текущая транзакция и если ее нет, то он ее и не открывает
                    и ничего не делает;
                - MANDATORY - смотрит, сущесвует ли текущая транзакция и если ее нет, то он ее и не открывает
                    и пробрасывает исключение;
                - REQUIRES_NEW - в отличии от REQUIRED в любом случае создает новую транзакцию, и приостанавливает
                    существующую, если она была. Но тут нужно понимать, что новая транзакция - это новое соединение.
                    А значит мы пойдем в пулл и будем там ждать освобождения соединения, что чревато deadlock;
                - NOT_SUPPORTED - такой метож в дюбом случае будет выполняться не в транзакции. А если транзакция открыта,
                    она приостанавливается;
                - NEVER - выполняетя не в транзакции и пробрасывает исключение, если транзакция открыта;
                - NESTED - работает только с JDBC-DataSourceTransactionManager, а значит не поддерживается
                    в текущем JPA-TransactionManager. Работает по savePoint - если вы вызвали setSavepoint(), то все
                    изменения до этого метса будут закоммичены и если после этого места произойдет exception, то то, что
                    закоммитили не потеряется.

        2. Isolation isolation() default Isolation.DEFAULT
            Уровни изоляции. По умолчанию дефолт, что значитт дефолтное для выбранной СУБД. У нас postgres - READ_COMMITED.
            Нужно обратить внимание, что isolation влияет только когда у нас открывается новая транзакция,
            т.е. REQUIRED и REQUIRES_NEW. Простыми словами: если мы пришли в метод с уже открытой транзакцией в другом
            методе, то ничего мы менять не будем. Мы не управляем этой транзакцией.

        3. boolean readOnly() default false;
            Если метод, делает только чтение и ничего не изменяет, то лучше установить readOnly=true

        4. Class<? extends Throwable>[] rollBackFor() default {};
            указывает в каких случаях, при каких исключениях нам нужно делать rollback транзакции. По умолчанию для
            RuntimeExceptions и Error. И если у нас есть какие-то checkedExceptions, то нам нужно обработать их явно
            и указать, если нам это нужно.

        5. String[] rollBackForClassName() default {};
            Аналог верхнего, просто если нет доступа к классу, то можно просто указать его имя.

        6. Class<? extends Throwable>[] noRollBackFor() default {};
            обратный 4-му

        7. String[] noRollBackForClassName() default {};
            обратный 5-му
