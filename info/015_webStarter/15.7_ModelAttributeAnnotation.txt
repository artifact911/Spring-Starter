На самом деле Спринг сам может достать атрибуты, вместо того, что бы мы их сетали через modelAndView.addObject().
    Но прежде:
        Нам не обязательно передавать ModelAndView, если хотит передать просто какую-то статическую страничку и уже с
        нее передавать какие-то данные.
        Тогда мы можем из контроллера возвращать String указывающий на путь к этой самой статической страничке.
          returnValueHandler поймет, что это SpringMVC и пойдет и возьмет статическую страничку по указанному адресу.
            @GetMapping("/bye")
            public String bye(@SessionAttribute("user") UserReadDto user) {
                return "greeting/bye";
            }

    Но тогда возникает проблема, т.к. нам не удобно работать и с Model и с View. Мы хотим работать только с моделью,
        а вью мы и так передаем строкой. Для этого мы инжектим не ModelAndView, а Model.
        Теперь мы можем в контроллер передать UserReadDto
            @GetMapping("/hello/")
            public String hello(Model model, HttpServletRequest request, UserReadDto userReadDto) {
        и передать все поля этой ДТО параметрами запроса. Тогда Спринг увидит это и под катотом соберет нам Model
        из полей нашего ДТО (далее мы будем доставть эти поля из формы запроса). Теперь к нашей ДТО мы можем обращаться
        из любого места, напрмер из jsp
            <body>
                Hello ${requestScope.userReadDto.username}!
            </body>
        На самом деле тут неявно используетя @ModelAttribute UserReadDto userReadDto, просто эту аннтоцию часто опускают
        в виду ненадобности. Но если мы хотим изменить название ключа нашего атрибута, то в аннотации мы указываем ключ,
        который будет иметь наш атрибут.
            @ModelAttribute("userReadDto")

        @ModelAttribute можно поставить над методом, возвращаемое значение которого и будет добавлено тоже, как артибут.
            @ModelAttribute("roles")
            public List<Role> roles() {
                return Arrays.asList(Role.values());
            }
        Тут есть нюанс, этот метод roles() будет вызываться при любом вызове в контроллер.