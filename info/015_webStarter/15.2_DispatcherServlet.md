### Жизненный цикл Dispatcher Servlet
![dispatcher servlet 1.png](015scr%2Fdispatcher%20servlet%201.png)

- Dispatcher Servlet - это обычнвй сервлет, а значит у него точно такой же жизненный цикл, как и у всех других сервлетов. 
    Т.е. когда у нас приходит запрост от нашего клиента по http у нас его принимает Coyote(HTTP Connector) и далее он преобразовывет его 
    его в соответствующий класс coyote.Request.class. После этого наш запрос попадает в другой модуль by ApacheTomcat - 
    Catalina(servlet container) и тут мы маппим наш request на соответствующий сервлет, который будет его обрабатывать.
    Напоминаю, у нас один единственный сервлет, который проинициализируется один раз и больше он инициализироваться не будет.
    Инициализация происходит в несколько шагов:
  1. 
     - Загрузка класса сервлета в память JVM
     - создание инстанса этого сервлета через Reflection API
     - вызываем у сервоета метод init()
  2. 
     - Теперь, когда сервлет проинициализирован, он может принимать http-запросы (servlet.service(req, resp)). И теперь, 
     пока мы не положили наше приложение, каждый раз будет вызваться метод service().
  3. 
     - когда мы завершаем наше прилодение, один единственный раз вызывается метод servlet.destroy()
  
Вся логика происходит в методе service(), разберемся, что там происходит:
![dispatcher servlet 2.png](015scr%2Fdispatcher%20servlet%202.png)
  1. Мы должны понять по нашему url какой обработчик будет у нашего запроса (раньше по url мы определяли, какой сервоет, 
    то сейчас сервлет понятен, поэтому мы должны определить handler)
  2. В свою очередь handler из себя представляет контроллер, а точнее метод этого контроллера, который будет обрабатывать 
    наш http зарос. Более того в handler есть еще и интрсепторы - аналог фильтров, только срабатывают не перед и после сервлетов, 
    а перед и после вызова метода контроллера. Поэтому в Спринге мы можем использовать как фильты, так и интерсепторы.
  3. Теперь, когда мы определили, какой интерспетор и контроллер будут вызываться, мы должны определить хэндлер-адаптер.
     Хэндлер-адаптер довольно интерсный класс, т.к. включает в себя много других вспомогательных объектов. 
     - В первую очередь в адаптере есть ссылка на WebApplicationContext. Как только мы подключили web-завасимость у нас 
     будет подключасться WebApplicationContext, а не обычный applicationContext. 
     Более того, хэндлер-адаптер включает в себя:
     - Набор HandlerMethodArgumentResolver - нужны чтобы понять, что заинжектить в матоды нашего контроллера (можем попросить 
     любые типы данных, любые бины и т.д. - все что нужно заинжектить как только наш http-запрос дошел до нашего метода контроллера)
     - Набор HandlerMethodReturnValueHandler - и как только мы обработали запрос в resolver, нам нужно вернуть какое-то значение.
        И это умеет делать ReturnValueHandler (например, мы захотим вернуть view, image, object для преобразование в json)
  4. И вот когда мы определили Handler мы просто вызываем у него метод handle(req, resp, handler). Возвращаемое тут значение 
    будет ModelAndView mv.
  5.  MV может быть null и так чаще всего и будет, потому что рендеринг страниц на стороне сервера не так часто используется  
     в современных прилодениях, т.к. чаще используются rest - возврщают данные, а не страницы. А значит используется 
     @ResponseBody чтобы ModelAndView у нас не возвращался и тогда мы возвращаем данные "как есть" - все, что мы установили 
     в response, то и вернется пользователю. В противном случае, наше ModelAndView должно каким-то образом отрендерится.
  6. И для такого рендеринга у нас есть viewResolvers, которые по названию странички, например "Hello.jsp" знает, где ее 
     найти в приложении (физически где лежит) и после этого мы у View можем вызвать метод View.render(mv.getModel())
  7. На этом обработка запроса заканчивается, а если exception, то мы его отлавливаем и обрабатываем его отдельно и для 
     этого у нас есть HandlerExceptionResolver.resolveException(ex) в нашем DispatcherServlet - можем вернуть другую страничку, 
     либо errorPage.
  8. На практике разработчик чаще всего будет реализовывать контроллеры, реже интерсепторы, HandlerExceptionResolvers и View